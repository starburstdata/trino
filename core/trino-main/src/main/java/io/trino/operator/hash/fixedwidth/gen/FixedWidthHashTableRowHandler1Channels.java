/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.operator.hash.fixedwidth.gen;

import io.trino.operator.hash.ColumnValueExtractor;
import io.trino.operator.hash.GroupByHashTableEntries;
import io.trino.operator.hash.HashTableRowHandler;
import io.trino.operator.hash.fastbb.FastByteBuffer;
import io.trino.operator.hash.fixedwidth.FixedWidthEntryStructure;
import io.trino.operator.hash.fixedwidth.FixedWidthGroupByHashTableEntries;
import io.trino.spi.Page;
import io.trino.spi.block.Block;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Objects.requireNonNull;

/**
 * This class has been generated by the FixedWidthHashTableRowHandlerGenerator class.
 * The generation is a one-time event and is not repeated during build
 */
public final class FixedWidthHashTableRowHandler1Channels
        implements HashTableRowHandler
{
    private final ColumnValueExtractor columnValueExtractor0;

    public FixedWidthHashTableRowHandler1Channels(FixedWidthEntryStructure structure)
    {
        requireNonNull(structure, "structure is null");
        checkArgument(structure.getHashChannelsCount() == 1);
        columnValueExtractor0 = structure.getColumnValueExtractors()[0];
    }

    @Override
    public void putEntry(GroupByHashTableEntries data, int entriesPosition, int groupId, Page page,
            int position, long rawHash)
    {
        FixedWidthGroupByHashTableEntries entries = (FixedWidthGroupByHashTableEntries) data;
        entries.putGroupId(entriesPosition, groupId);
        entries.putHash(entriesPosition, rawHash);
        int valuesOffset = entries.getValuesOffset(entriesPosition);
        FastByteBuffer buffer = entries.getBuffer();
        Block block0 = page.getBlock(0);
        byte value0IsNull = (byte) (block0.isNull(position) ? 1 : 0);
        entries.putIsNull(entriesPosition, 0, value0IsNull);
        columnValueExtractor0.putValue(buffer, valuesOffset, block0, position);
    }

    @Override
    public boolean keyEquals(GroupByHashTableEntries data, int entriesPosition, Page page,
            int position, long rawHash)
    {
        FixedWidthGroupByHashTableEntries entries = (FixedWidthGroupByHashTableEntries) data;
        int valuesOffset = entries.getValuesOffset(entriesPosition);
        FastByteBuffer buffer = entries.getBuffer();
        Block block0 = page.getBlock(0);
        boolean block0ValueNull = block0.isNull(position);
        boolean entriesValue0IsNull = entries.isNull(entriesPosition, 0) == 1;
        if (block0ValueNull != entriesValue0IsNull) {
            return false;
        }
        return block0ValueNull || columnValueExtractor0.valueEquals(buffer, valuesOffset, block0, position);
    }
}
