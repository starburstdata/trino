/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.trino.operator.hash.fixedwidth;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import io.trino.operator.hash.ColumnValueExtractor;
import io.trino.operator.hash.GroupByHashTableEntries;
import io.trino.operator.hash.HashTableRowHandler;
import io.trino.operator.hash.fastbb.FastByteBuffer;
import io.trino.spi.Page;
import io.trino.spi.block.Block;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Objects;

import static java.lang.String.format;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;

/**
 * This class can be used to generate FixedWidthHashTableRowHandlerXChannels classes.
 * This is a one time generation not invoked during build time.
 * In order to generate new version of classes:
 * <ul>
 * <li>Run main method of this class</li>
 * <li>Add license header to created classes (unsupported in Java poet)</li>
 * <li>Format/optimize imports</li>
 * </ul>
 * The class is placed in the test code to prevent unnecessary dependencies in main.
 */
public class FixedWidthHashTableRowHandlerGenerator
{
    public static final String MODULE_NAME = "core/trino-main";
    public static final Package PACKAGE = GenericFixedWidthHashTableRowHandler.class.getPackage();
    public static final String CLASS_COMMENT = "This class has been generated by the FixedWidthHashTableRowHandlerGenerator class.\n" +
            "The generation is a one-time event and is not repeated during build";

    private FixedWidthHashTableRowHandlerGenerator() {}

    public static void generate(int numberOfChannels)
            throws IOException
    {
        generate(numberOfChannels, true);
    }

    public static void generate(int numberOfChannels, boolean inline)
            throws IOException
    {
        String className = "FixedWidthHashTableRowHandler" + numberOfChannels + "Channels";
        TypeSpec.Builder mainClass = TypeSpec.classBuilder(className)
                .addSuperinterface(HashTableRowHandler.class)
                .addJavadoc(CLASS_COMMENT)
                .addModifiers(PUBLIC, FINAL);

        for (int i = 0; i < numberOfChannels; i++) {
            mainClass.addField(ColumnValueExtractor.class, "columnValueExtractor" + i, PRIVATE, FINAL);
        }

        // we are starting at 1 as we know the value0Offset is always 0
        for (int i = 1; i < numberOfChannels; i++) {
            mainClass.addField(int.class, format("value%dOffset", i), PRIVATE, FINAL);
        }

        mainClass.addMethod(constructor(numberOfChannels));
        mainClass.addMethod(putEntry(numberOfChannels, inline));
        if (!inline) {
            for (int i = 0; i < numberOfChannels; i++) {
                mainClass.addMethod(putValue(i));
            }
        }
        mainClass.addMethod(keyEquals(numberOfChannels, inline));
        if (!inline) {
            for (int i = 0; i < numberOfChannels; i++) {
                mainClass.addMethod(valueEquals(i));
            }
        }

        JavaFile javaFile = JavaFile.builder(PACKAGE.getName() + ".gen", mainClass.build())
                .indent("    ")
                .addStaticImport(Objects.class, "requireNonNull")
                .addStaticImport(com.google.common.base.Preconditions.class, "checkArgument")
                .build();

        javaFile.writeTo(getSrcDir());
        System.out.printf("generated %s to %s\n", className, getSrcDir());
    }

    private static MethodSpec constructor(int numberOfChannels)
    {
        MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                .addModifiers(PUBLIC)
                .addParameter(FixedWidthEntryStructure.class, "structure");

        constructor.addStatement("requireNonNull(structure, \"structure is null\")");
        constructor.addStatement("checkArgument(structure.getHashChannelsCount() == $1L)", numberOfChannels);

        for (int i = 0; i < numberOfChannels; i++) {
            constructor.addStatement("columnValueExtractor$1L = structure.getColumnValueExtractors()[$1L]", i);
        }

        for (int i = 1; i < numberOfChannels; i++) {
            constructor.addStatement("value$1LOffset = structure.getValuesOffsets()[$1L]", i);
        }

        return constructor
                .build();
    }

    private static MethodSpec putEntry(int numberOfChannels, boolean inline)
    {
        MethodSpec.Builder method = MethodSpec.methodBuilder("putEntry")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .addParameter(GroupByHashTableEntries.class, "data")
                .addParameter(int.class, "entriesPosition")
                .addParameter(int.class, "groupId")
                .addParameter(Page.class, "page")
                .addParameter(int.class, "position")
                .addParameter(long.class, "rawHash");

        method.addStatement("$1T entries = ($1T) data", FixedWidthGroupByHashTableEntries.class);
        method.addStatement("entries.putGroupId(entriesPosition, groupId)");
        method.addStatement("entries.putHash(entriesPosition, rawHash)");
        method.addStatement("int valuesOffset = entries.getValuesOffset(entriesPosition)");
        method.addStatement("$1T buffer = entries.getBuffer()", FastByteBuffer.class);

        for (int channel = 0; channel < numberOfChannels; channel++) {
            if (!inline) {
                method.addStatement("putValue$1L(entriesPosition, page, position, entries, valuesOffset, buffer)", channel);
            }
            else {
                method.addStatement("Block block$1L = page.getBlock($1L)", channel);
                method.addStatement("byte value$1LIsNull = (byte) (block$1L.isNull(position) ? 1 : 0)", channel);
                method.addStatement("entries.putIsNull(entriesPosition, $1L, value$1LIsNull)", channel);
                if (channel == 0) {
                    method.addStatement("columnValueExtractor$1L.putValue(buffer, valuesOffset, block$1L, position)", channel);
                }
                else {
                    method.addStatement("columnValueExtractor$1L.putValue(buffer, valuesOffset + value$1LOffset, block$1L, position)", channel);
                }
            }
        }

        return method.build();
    }

    private static MethodSpec putValue(int channel)
    {
        MethodSpec.Builder method = MethodSpec.methodBuilder("putValue" + channel)
                .addModifiers(PRIVATE)
                .addParameter(int.class, "entriesPosition")
                .addParameter(Page.class, "page")
                .addParameter(int.class, "position")
                .addParameter(FixedWidthGroupByHashTableEntries.class, "entries")
                .addParameter(int.class, "valuesOffset")
                .addParameter(FastByteBuffer.class, "buffer");

        method.addStatement("Block block$1L = page.getBlock($1L)", channel);
        method.addStatement("byte value$1LIsNull = (byte) (block$1L.isNull(position) ? 1 : 0)", channel);
        method.addStatement("entries.putIsNull(entriesPosition, $1L, value$1LIsNull)", channel);
        if (channel == 0) {
            method.addStatement("columnValueExtractor$1L.putValue(buffer, valuesOffset, block$1L, position)", channel);
        }
        else {
            method.addStatement("columnValueExtractor$1L.putValue(buffer, valuesOffset + value$1LOffset, block$1L, position)", channel);
        }
        return method.build();
    }

    private static MethodSpec keyEquals(int numberOfChannels, boolean inline)
    {
        MethodSpec.Builder method = MethodSpec.methodBuilder("keyEquals")
                .addModifiers(PUBLIC)
                .addAnnotation(Override.class)
                .returns(boolean.class)
                .addParameter(GroupByHashTableEntries.class, "data")
                .addParameter(int.class, "entriesPosition")
                .addParameter(Page.class, "page")
                .addParameter(int.class, "position")
                .addParameter(long.class, "rawHash");

        method.addStatement("$1T entries = ($1T) data", FixedWidthGroupByHashTableEntries.class);
        method.addStatement("int valuesOffset = entries.getValuesOffset(entriesPosition)");
        method.addStatement("$1T buffer = entries.getBuffer()", FastByteBuffer.class);
        for (int channel = 0; channel < numberOfChannels - 1; channel++) {
            if (!inline) {
                method.beginControlFlow("if(!value$1LEquals(entriesPosition, page, position, entries, valuesOffset, buffer))", channel);
                method.addStatement("return false");
                method.endControlFlow();
            }
            else {
                method.addStatement("$2T block$1L = page.getBlock($1L)", channel, Block.class);
                method.addStatement("boolean block$1LValueNull = block$1L.isNull(position)", channel);
                method.addStatement("boolean entriesValue$1LIsNull = entries.isNull(entriesPosition, $1L) == 1", channel);
                method.beginControlFlow("if (block$1LValueNull != entriesValue$1LIsNull)", channel);
                method.addStatement("return false");
                method.endControlFlow();
                if (channel == 0) {
                    method.beginControlFlow("if (!block$1LValueNull && !columnValueExtractor$1L.valueEquals(buffer, valuesOffset, block$1L, position))", channel);
                }
                else {
                    method.beginControlFlow("if (!block$1LValueNull && !columnValueExtractor$1L.valueEquals(buffer, valuesOffset + value$1LOffset, block$1L, position))", channel);
                }
                method.addStatement("return false");
                method.endControlFlow();
            }
        }

        if (!inline) {
            method.addStatement("return value$1LEquals(entriesPosition, page, position, entries, valuesOffset, buffer)", numberOfChannels - 1);
        }
        else {
            int lastChannel = numberOfChannels - 1;
            method.addStatement("$2T block$1L = page.getBlock($1L)", lastChannel, Block.class);
            method.addStatement("boolean block$1LValueNull = block$1L.isNull(position)", lastChannel);
            method.addStatement("boolean entriesValue$1LIsNull = entries.isNull(entriesPosition, $1L) == 1", lastChannel);
            method.beginControlFlow("if (block$1LValueNull != entriesValue$1LIsNull)", lastChannel);
            method.addStatement("return false");
            method.endControlFlow();
            if (lastChannel == 0) {
                method.addStatement(
                        "return block$1LValueNull || " +
                                "columnValueExtractor$1L.valueEquals(buffer, valuesOffset, block$1L, position)",
                        lastChannel);
            }
            else {
                method.addStatement(
                        "return block$1LValueNull || " +
                                "columnValueExtractor$1L.valueEquals(buffer, valuesOffset + value$1LOffset, block$1L, position)",
                        lastChannel);
            }
        }
        return method.build();
    }

    private static MethodSpec valueEquals(int channel)
    {
        MethodSpec.Builder method = MethodSpec.methodBuilder("value" + channel + "Equals")
                .addModifiers(PRIVATE)
                .returns(boolean.class)
                .addParameter(int.class, "entriesPosition")
                .addParameter(Page.class, "page")
                .addParameter(int.class, "position")
                .addParameter(FixedWidthGroupByHashTableEntries.class, "entries")
                .addParameter(int.class, "valuesOffset")
                .addParameter(FastByteBuffer.class, "buffer");

        method.addStatement("$2T block$1L = page.getBlock($1L)", channel, Block.class);
        method.addStatement("boolean block$1LValueNull = block$1L.isNull(position)", channel);
        method.addStatement("boolean entriesValue$1LIsNull = entries.isNull(entriesPosition, $1L) == 1", channel);
        method.beginControlFlow("if (block$1LValueNull != entriesValue$1LIsNull)", channel);
        method.addStatement("return false");
        method.endControlFlow();

        if (channel == 0) {
            method.addStatement(
                    "return block$1LValueNull || " +
                            "columnValueExtractor$1L.valueEquals(buffer, valuesOffset, block$1L, position)",
                    channel);
        }
        else {
            method.addStatement(
                    "return block$1LValueNull || " +
                            "columnValueExtractor$1L.valueEquals(buffer, valuesOffset + value$1LOffset, block$1L, position)",
                    channel);
        }
        return method.build();
    }

    private static Path getSrcDir()
    {
        return Paths.get(MODULE_NAME)
                .resolve("src")
                .resolve("main")
                .resolve("java");
    }

    public static void main(String[] args)
            throws IOException
    {
        for (int i = 1; i <= 20; i++) {
            generate(i);
        }
    }
}
